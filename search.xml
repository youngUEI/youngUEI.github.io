<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue过渡效果]]></title>
    <url>%2F2018%2F06%2F01%2Fvue%E8%BF%87%E6%B8%A1%2F</url>
    <content type="text"><![CDATA[纠结好久的过渡问题终于解决了，vue过渡实现的过程从头到尾梳理了一遍，嗯，过程很清楚，赶快把思路记录下来，便于以后参考 v-enter : 目标元素进入过渡开始时一瞬间的状态 v-enter-to ： 目标元素在过渡结束时的状态 v-enter-active ： 目标元素在整个过渡阶段的状态 v-leave ： 目标元素离开过渡开始时一瞬间的状态 v-leave-to ： 目标元素在过渡结束时的状态 v-leave-active ：目标元素在整个过渡阶段的状态 所有的过渡样式只会在过渡过程中有效 opacity: 默认值为1 表示完全不透明 （opacity：不透明度 1表示完全不透明 0表示完全透明） 过渡效果实例实例：效果为点击按钮div区域淡入淡出 12345678910111213141516171819202122232425262728293031323334...&lt;style&gt; .div1&#123; width:200px; height:200px; background:orange; &#125; .fade-enter&#123; opacity:0; &#125; .fade-enter-active&#123; transition:opacity 5s; &#125; .fade-leave-active&#123; opacity:0; transition:opacity 5s; &#125;&lt;/style&gt;...&lt;div id="app"&gt; &lt;button v-on:click='show = !show'&gt;toggle&lt;/button&gt; &lt;transition name="fade"&gt; &lt;div v-if="show" class="div1"&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt;...&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; show:true &#125; &#125;)&lt;/script&gt; 代码分析: 1234567891011121314151617&lt;style&gt; .div1&#123; width:200px; height:200px; background:orange; &#125; .fade-enter&#123; opacity:0; &#125; .fade-enter-active&#123; transition:opacity 5s; &#125; .fade-leave-active&#123; opacity:0; transition:opacity 5s; &#125;&lt;/style&gt; 当点击按钮图片出现的时候，我们希望它不要立刻出现，要将其完全透明，利用过渡效果，逐渐出现；当点击按钮图片消失的时候，我们希望它不要立刻消失，要利用过渡效果使其逐渐消失。 div进入时候，fade-enter 在进入一瞬间将其设置为全透明，由于div进入的状态最终为不透明，所以fade-enter-to可以不用设置，整个进入过渡中fade-enter-active采用将透明度作为过渡效果并持续5秒 div离开时候，因为div是不透明的，那么fade-leave 可以不用设置，在过渡结束的时候需要将其设置为完全透明，此时可以使用fade-leave-to来定义过渡结束时的状态，但是也可以将其写在fade-enter-active中，整个离开过渡中fade-enter-active采用将透明度作为过渡效果并持续5秒 将style代码也可以改写为: 12345678910111213141516171819202122&lt;style&gt; .div1&#123; width:200px; height:200px; background:orange; &#125; /*淡入*/ .fade-enter&#123; opacity:0; &#125; .fade-enter-to&#123;opacity:1;&#125; /*fade-enter-to也可以不用，因为最终状态同样为不透明*/ .fade-enter-active&#123; transition:opacity 5s; /*在div进入的整个过程中采用的过渡效果*/ &#125; /*淡出*/ .fade-leave&#123;opacity:1&#125; /*fade-leave也可以不用，因为离开过渡开始的一瞬间div本身就是完全不透明的*/ .fade-leave-to&#123;opacity:0&#125; .fade-leave-active&#123; transition:opacity 5s; /*在div离开的整个过程中采用的过渡效果*/ &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue注册组件步骤]]></title>
    <url>%2F2018%2F06%2F01%2Fvue%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[组件是可复用的Vue实例，组件与实例类似也是接受相同的选项，但是仅有根实例才会有el这样的选项，组件中data选项必须是函数的形式与根实例不同。 1.注册组件基础写法注册全局组件 Vue.extend(options) 创建了一个子类，参数为组件选项组成的对象 Vue.component(‘组件名’，组件的构造器) 实例化组件 （组件需要挂载到某个Vue的实例下，否则不会生效） 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; let component1 = Vue.extend(&#123; template: `&lt;div class=&quot;base-style class1&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data()&#123; return&#123; msg : &apos;this is my-component &apos; &#125; &#125; &#125;); Vue.component(&quot;my-component&quot;, component1); new Vue(&#123; el: &quot;#app&quot;, &#125;)&lt;/script&gt; 注册局部组件 创建一个组件构造器 Vue.extend() 在vue实例下的components选项下将组件注册为局部组件并挂载到该Vue实例上 components:{‘组件名’：组件的构造器} 2.注册组件语法糖注册全局组件Vue.component(&#39;组件名&#39;，{/*......*/}) 传入一个选项对象，这会自动调用Vue.extend 12345678Vue.component(&apos;my-component&apos;,&#123; template: `&lt;div class=&quot;base-style class1&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data()&#123; return&#123; msg : &apos;this is my-component &apos; &#125; &#125;&#125;) 组测局部组件需要在vue实例的components选项中注册 12345678910111213new Vue(&#123; el: &apos;#app&apos;, components:&#123; &apos;my-component&apos;:&#123; template: `&lt;div class=&quot;base-style class1&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data()&#123; return&#123; msg : &apos;this is my-component &apos; &#125; &#125; &#125; &#125;&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中事件监听与触发]]></title>
    <url>%2F2018%2F05%2F31%2FVue%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[v-on事件监听v-on监听某个事件，当事件触发后会执行相应的操作 以下为一个事件监听实例，具体效果为：页面上默认有三条数据，当用户在输入框输入并回车后，将数据添加到列表，点击列表项的x可以实现删除这一项。 12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;input v-model="newTodoText" placeholder="Add a todo" v-on:keyup.enter="todoList.unshift(newTodoText);newTodoText=''"/&gt; &lt;ol&gt; &lt;my-component v-for="(todo,index) in todoList" v-bind:key="index" v-bind:thing="todo" v-on:removething="todoList.splice(index,1)"&gt;&#123;&#123;todo&#125;&#125; &lt;/my-component&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; newTodoText:'', todoList :[ 'Learn Git', 'Learn Webpack', 'Learn Vue-cli' ] &#125;, components:&#123; 'my-component':&#123; template: `&lt;li&gt;&#123;&#123;thing&#125;&#125; &lt;button v-on:click="$emit('removething')"&gt;x&lt;/button&gt;&lt;/li&gt;`, props:['thing'], &#125; &#125; &#125;)&lt;/script&gt; 代码分析 组件my-component被点击后触发removething事件 在父组件中监听removething事件，等其触发后执行操作数组todoList的代码 其中： 当组件被循环的时候，需要添加key属性 1&lt;my-component v-for="(todo,index) in todoList" v-bind:key="index" v-bind:thing="todo" v-on:removething="todoList.splice(index,1)"&gt;&#123;&#123;todo&#125;&#125; &lt;/my-component&gt; 当然这个组件可以重写为： 1&lt;li is="my-component" v-for="(todo,index) in todoList" v-bind:thing="todo" v-on:removething="todoList.splice(index,1)"&gt;&#123;&#123;todo&#125;&#125; &lt;/li&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
        <tag>Vue事件监听</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中绑定class的几种方法]]></title>
    <url>%2F2018%2F05%2F31%2FVue%E4%B8%AD%E7%BB%91%E5%AE%9Aclass%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[vue中元素绑定class1.使用对象绑定1234567891011121314151617181920212223242526272829303132...&lt;style type="text/css" media="screen"&gt; .base-style&#123; height:100px; width:100px; border: 1px solid #ccc; &#125; .class1&#123; background-color: orange; &#125; .class2&#123; border-radius: 50%; &#125;&lt;/style&gt;...&lt;div id="app"&gt; &lt;div class="base-style" :class="&#123;class1:classValue1,class2:classValue2&#125;"&gt;&lt;/div&gt; &lt;div class="base-style" :class="classObj"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; classValue1:true, classValue2:true, classObj:&#123; class1: true, class2: false, &#125; &#125; &#125;)&lt;/script&gt; 最终渲染为： 12&lt;div class=&quot;base-style class1 class2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;base-style class1 &quot;&gt;&lt;/div&gt; 2.使用数组绑定1234567891011121314...&lt;div id="app"&gt; &lt;div class="base-style" :class="[classStyle1,classStyle2]"&gt;&lt;/div&gt;&lt;/div&gt;...&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; classStyle1: 'class1', classStyle2: 'class2', &#125; &#125;)&lt;/script&gt; 最终渲染为：&lt;div class=&quot;base-style class1 class2&quot;&gt;&lt;/div&gt; 3.将class绑定到组件上12345678910111213141516171819...&lt;div id="app"&gt; &lt;my-components class="base-style"&gt;&lt;/my-components&gt;&lt;/div&gt;...&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; classStyle1: 'class1', classStyle2: 'class2', &#125;, components:&#123; 'my-components':&#123; template: '&lt;div class="class1 class2"&gt;&lt;/div&gt;' &#125; &#125; &#125;)&lt;/script&gt; 最终渲染为： 123&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;base-style class1 class2&quot;&gt;&lt;/div&gt;&lt;/div&gt; 组件上的class将会传递到组件template内 &lt;my-component class=&quot;base-style&quot;&gt;&lt;/my-component&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue父子组件简单介绍]]></title>
    <url>%2F2018%2F05%2F30%2Fvue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1. 理解父子组件可以简单的理解为： 在a组件的模板template中使用的b组件，这个b组件就是a的子组件，a为b的父组件 但是经过个人分析后认为： 在a组件的模板template中使用的b组件，这个b组件的template中的内容才是a的子组件，详细分析见：父子组件通讯 父子组件实例1234567891011121314151617181920212223...&lt;body&gt; &lt;div id="app"&gt; &lt;parent-component&gt;&lt;/parent-component&gt; &lt;/div&gt;&lt;/body&gt;&lt;script text="text/javascript"&gt; var child = Vue.extend(&#123; template:`&lt;div&gt;child&lt;/div&gt;` &#125;); var parent = Vue.extend(&#123; template:`&lt;div&gt;在父组件内部使用子组件必须先注册:&lt;child-component&gt;&lt;/child-component&gt;&lt;/div&gt;`, components:&#123; 'child-component': child, //注册子组件，并将其标签名定义为child-component &#125;, &#125;); new Vue(&#123; el: "#app", components:&#123; 'parent-component': parent, &#125; &#125;)&lt;/script&gt; &lt;div&gt;在父组件内部使用子组件必须先注册:&lt;child-compoent&gt;&lt;/child-component&gt;&lt;/div&gt; 这里父组件中使用子组件child-component 父组件给子组件传值123456789101112131415161718192021222324252627282930...&lt;body&gt; &lt;div id="app"&gt; &lt;parent-component&gt;&lt;/parent-component&gt; &lt;!--父组件--&gt; &lt;/div&gt;&lt;script text="text/javascript"&gt; var child = Vue.extend(&#123; template:`&lt;div&gt;子组件接受的信息为：&#123;&#123;parentName&#125;&#125;,&#123;&#123;parentSex&#125;&#125;&lt;/div&gt;`, props:['parentName','parentSex'], &#125;); var parent = Vue.extend(&#123; template:`&lt;div&gt;父组件信息已传递给子组件：&lt;child-component :parent-name="name" :parent-sex="sex"&gt;&lt;/child-component&gt;&lt;/div&gt;`, components:&#123; 'child-component': child, //注册子组件，并将其标签名定义为child-component &#125;, data()&#123; return &#123; name: 'younguei', sex: 'male', &#125; &#125; &#125;); new Vue(&#123; el: "#app", components:&#123; 'parent-component': parent, &#125; &#125;)&lt;/script&gt; 这个实例有一个父组件、子组件、“孙组件”，实际是实例vm上挂载一个子组件parent-component,该子组件又挂载一个子组件child-component]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue父子组件通信]]></title>
    <url>%2F2018%2F05%2F30%2Fvue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[1. 父子组件通讯父组件给子组件传递信息实例 子组件给父组件传递信息123456789101112131415161718192021222324252627282930313233343536...&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;count&#125;&#125; &lt;count-btn v-on:increment="addOne"&gt;&lt;/count-btn&gt; &lt;!--子组件--&gt; &lt;count-btn v-on:increment="addOne"&gt;&lt;/count-btn&gt; &lt;!--子组件--&gt; &lt;/div&gt; &lt;script text="text/javascript"&gt; Vue.component('count-btn',&#123; template:`&lt;button v-on:click="add"&gt;&#123;&#123;btnCount&#125;&#125;&lt;/button&gt;`, methods:&#123; add()&#123; this.btnCount++; this.$emit('increment'); &#125; &#125;, data()&#123; return&#123; btnCount:0, &#125; &#125;, &#125;) new Vue(&#123; el: "#app", data:&#123; count : 0, &#125;, methods:&#123; addOne()&#123; this.count++; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 关于父子组件:12345&lt;div id="app"&gt; &#123;&#123;count&#125;&#125; &lt;count-btn v-on:increment="addOne"&gt;&lt;/count-btn&gt; &lt;!--子组件--&gt; &lt;count-btn v-on:increment="addOne"&gt;&lt;/count-btn&gt; &lt;!--子组件--&gt;&lt;/div&gt; 这里的&lt;count-btn v-on:increment=&quot;addOne&quot;&gt;&lt;/count-btn&gt; 是父组件的一部分，count-btn组件模板template为子组件，子组件为&lt;button v-on:click=&quot;add&quot;&gt;&lt;/button&gt; 分析代码 子组件给父组件传递信息经历的步骤： 子组件监听click事件 &lt;button v-on:click=&quot;add&quot;&gt;&lt;/button&gt; 当触发click事件后，会执行add函数 add 函数中this.$emit(&#39;increment&#39;); 会触发increment事件 父组件&lt;count-btn v-on:increment=&quot;addOne&quot;&gt;&lt;/count-btn&gt; 时刻在监听increment时间，子组件触发该事件后，会执行addOne函数，从而实现子组件给父组件通讯，使得父组件在子组件点击后自增1.]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT常用指令]]></title>
    <url>%2F2018%2F05%2F28%2Fhexo%E5%8F%8Anext%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[利用Hexo+NexT博客搭建完毕后，这里有一些常用的命令 1.写一篇博客 $hexo new articleTitle 采用默认的post的样式创建一个articleTitle文章 $hexo new [articleStyle] articleTitle 采用articleStyle 样式创建一篇文章 2.博客中的各项参数 layout 文章采用的布局样式 title 标题，可以设置默认标题，在博客配置文件中，通过改变new_post_name 来改变默认文件名称。可以采用:year-:month-:day-:title.md 作为默认默认样式，方便文章管理 date 建立文章的日期 comments 开启文章评论功能，默认开启的，当文章不希望评论时，设置该值为false tags 文章标签,一个文章可能涉及多方面内容，可以多个标签 categories 文章分类，每一个文章只属于某一个类（最好只属于某一个类） description 用于在首页显示文章的概述 例子： （冒号后存在一个空格） 12345678910--- layout: post title: xxxx description: xxxx tags: - tag1 - tag2 - tag3 categories: categorie1--- 3.生成静态文件 $hexo generate 生成静态文件，这里是将文件根目录中的source文件夹内容转换成public静态文件夹 4.本地预览 $hexo server 创建本地服务器，博客开始运行。 注意： (1).在git bash中使用strl+c无法关闭服务器，是因为我这里的热键冲突，我的解决方案是采用Atom的命令行，这里可以正常关闭 (2).有时候修改了博客内容，刷新后仍然无效，这里是缓存的问题，使用$hexo clean命令，该命令会删除public文件夹，重新创建新的public文件夹 5.部署到线上 $hexo generate 生成静态文件，之前有提及 $hexo deploy 将网站部署到服务器，前提是你的git已经和线上服务器绑定，绑定很简单，百度。 这两条命令可以合并: $hexo g -d生成静态文件，并部署到线上]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础命令清单]]></title>
    <url>%2F2018%2F05%2F25%2Fgit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[git的初始设定git init 初始化项目仓库：会创建一个隐藏的.git文件夹 git help config 自动打开浏览器页面,显示对应命令的帮助文档 获取commit命令文档 git help commit 第一次提交 git init 在某个指定的文件夹内初始化仓库 创建一个新文件 git status git add 文件名 提交到索引区 git commit -m 提交描述 将索引区内容提交到本地仓库 git log 查看提交历史 查看提交历史 git log git log --oneline 将提交的历史简化为一行显示 git log -p 将提交历史详细输出 git log --oneline -5 最近5次履历 把握git状态 git status 查看内容状态 git checkout -- 文件名 将修改的（尚未提交到索引区）文件恢复到修改前状态 git reset HEAD 文件名 将提交到索引区域文件退出索引区，再次使用git checkout -- 文件名将文件恢复到以前 比较修改内容 git diff 只能比较尚未添加到索引区的文件内容 git diff --cached 索引区内容比较 git文件操作 git add [file1 file2 ...] 添加若干个文件到索引区 git add . 将当前工作目录内所有文件添加到索引区 gir mv oldfileName newfileName 文件移动，更多用于文件改名 git rm --cached filename 从索引区删除文件 （remove移出） 区别： git reset HEAD 文件名 文件从索引区内退出，此时可以编辑 git rm --cached filename 会从索引区删除文件，会显示untracked fileds当commit后文件就会删除 git忽略管理例如在使用vue-cli中不希望node_modules文件被git管理 方法：在.gitignore文件中设置不需要管理的文件即可 参考网页 在项目目录中创建.gitignore 在.gitignore 写入*.temp表示该文件结尾的文件不被管理 更新最后的提交 git commit -m &#39;message...&#39; git commit --amend 已提交的文件再次修改提交但是不希望有提交记录，这条命令表示将修改的内容合并到上一次，不产生记录 输入：wq 退出，操作成功。 返回过去 git reset --hard HEAD 返回最后一次提交版本 git reset --hard HEAD~ 返回倒数第二个版本 git reset --hard HEAD~n 返回倒数第n个版本 返回过去后再去未来： 记住id号码 git reset --hard HEAD 版本id 那么就会回到id对应的版本 当没记住id怎么回到未来 git reflog [-n num] 显示最近log记录对应的id git reset --hard [commit_id] 利用id来跳转到未来版本 使用分支 git branch [name] 创建新分支 git branch clean_up git checkout branch_name 跳转分支 git branch用于显示分支 合并分支 git merge branch_name合并分支 git branch -d branch_name删除分支 分支冲突解决多人同时编辑一个文件的时候，对相同代码在不同分支上进行不同操作，合并分支会产生冲突。 git checkout -b [branch_name] 建立一个新分支，并切换到该分支上 解决方法：手动解决冲突代码，之后提交到仓库 git commit -m &#39;merged by leader&#39; 使用tag标签任何软件系统，应用程序在发布时候都应该给一个版本号，用来管理每次发布的内容，便于管理。 tag标签用于版本管理 NNN.abc.xxx NNN:大版本号 abc: 每次做出的小更新版本 xxx: 每次bug修正时发布的版本 git tag [tag_name] 为当前仓库打一个标签 git show [tag_name] git tag -d [tag_name] git tag 显示当前版本标签 使用别名在git中可以将常用的命令设置简写 git config --global alias.[name] [command_name] git config -l 显示所有命令缩略语 git config --global alias.br branch 将branch命令简写为br 本地git仓库连接到远程github git remote add origin 远程仓库url地址 将本地仓库关联到远程仓库 git push -u origin master 将本地仓库内容推送到远程 第一次推送的时候需要添加-u参数，该参数的作用是将本地的master分支推送到远程master分支上 git push origin master 推送命令简化，在第二次及以后的推送时使用该命令，默认推送到master分支上。 从远程github克隆仓库最好先建远程库，再从远程克隆到本地 git clone 远程仓库url 克隆远程仓库到本地 添加git忽略管理文件 .gitignore在文件内添加 node_modules 看视频中随便敲的首次安装git需要设置用户名和邮箱git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;Your email&quot; pwd print working directory git config --list列出所有的配置 user.name user.email 都在其中 git status 查看当前项目的状态 git add 文件名 将对应的文件添加到stage区域中，stage区域中的文件可以被提交到仓库 git commit -m 操作描述将stage内所有文件提交到仓库 git add&#39;*.txt&#39; 利用通配符将所有新txt文件添加到stage中 git commit -m &#39;Add all the octocat txt files&#39; 将stage内所有的文件提交到仓库 git log 显示我们之前的操作 git remote add origin url 将本地仓库提交到远程仓库 url为远程仓库地址 git push -u origin master 远程仓库名为origin，默认分支名为master，-u表示保存配置，下次使用git push来直接提交到远程仓库 git pull origin master从远程仓库获取到本地 git diff HEAD 查看最近提交的不同之处 git diff --staged 用于查看staged区域中文件的变化 git reset 文件名将stage内对应的文件移出stage git checkout -- 文件名直接删除文件 git branch 分支名创建新分支 git checkout 分支名 将当前操作的分支切换到对应的分支名上 git re &#39;*.txt&#39; 利用通配符，移除对应的文件 git commit -m ’emove all the cats‘ git merge 分支名 将对应的分支名与当前的处在的分支合并 git branch -d 分支名 删除分支]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli笔记]]></title>
    <url>%2F2018%2F05%2F01%2FvueCli%2F</url>
    <content type="text"><![CDATA[Vue-cli安装vue-cli是构建单页面应用的脚手架 npm install vue-cli -g 检查vue-cli版本vue - V 初始化项目 vue init &lt;template-name&gt; &lt;project-name&gt; 初始化项目完毕后，就可以写自己的项目了。 注意： npm run dev报错 12Module build failed: Error: &quot;extract-text-webpack-plugin&quot; loader is used without the corresponding plugin, refer to https://github.com/webpack/extract-text-webpack-plugin for the usage example 解决方法:参考 在webpack.base.conf.js中添加以下代码 12345678910111213141516const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);.... &#123; test: /\.scss$/, use: ExtractTextPlugin.extract(&#123; use: [ &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;) &#125; ... plugins: [ new ExtractTextPlugin(&#123; filename: &apos;./[name].css&apos; &#125;) ] Vue-cli安装的webpack项目目录介绍几个重要的文件: dev-server.js 服务器文件 webpack.base.config.js webpack的基础配置文件 .babelrc 把ES6转换为ES5代码 .editorconfig 定义项目的编码规范，编译器的行为会与该文件中定义的一致，并且高于编译器自身的设置要高 index.html 项目的入口页面 main.js 程序入口文件，用于加载js与css等文件 App.vue 页面组件 疑问： 项目执行流程，页面入口index.html引入main.js ，main.js引入组件App.vue，index.js中路由怎么执行的，程序执行流程是什么，还需要vue-router内容来支撑。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JSpang系列教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开博客的原因]]></title>
    <url>%2F2017%2F11%2F20%2FmyBlog%2F</url>
    <content type="text"><![CDATA[简介通过各种查找资料，走过各种弯路，解决了一个接一个问题，博客初步完成了，博客的主要用途是记录自己前端学习历程，心情不好的时候也会写一些对生活的心得、感想，记录下自己那些难忘的岁月。 正文1、博客创建所用到的资源 GitHub 从零开始创建一个博客是很累人的，好在github上的开源博客项目，只需修改自己相关内容，可以更好的专注于博客内容的书写。 百度统计 博客浏览量统计，通过分析可以得到浏览博客网友的区域分布，浏览高峰时间段。 来必力 评论系统，很方便，几行代码copy到博客中，就可以显示评论区域框架结构，更棒的是可以在其网站上分析各种评论数据。 typora Markdown编辑器，所写即所得，高效、快捷。 2、鸣谢 [酒石酸菌] 基于 GitHub Pages 和 Jekyll 搭建个人博客的简单心得。 leopardpan 点击链接就可以访问原作者的Github的开源博客项目。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活记录</tag>
      </tags>
  </entry>
</search>
