<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Day28-Day30发个邮件吧]]></title>
    <url>%2F2018%2F07%2F01%2FDay28%E8%87%B3Day30%E5%8F%91%E4%B8%AA%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Web安全之XSS攻防跨站脚本攻击，向页面内恶意注入js代码，用户浏览页面时，注入的恶意js代码将会执行并攻击用户。 编码和解码尚未实现 我的作业 别人的代码]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day25-Day27倒数开始函数内容]]></title>
    <url>%2F2018%2F06%2F29%2FDay25%E8%87%B327select%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Date对象创建Date对象，new Date()该对象会自动把当前日期和时间保存为初始值 Date对象方法 Date(): 注意： 返回当前的日期和时间，不需要前置date对象实例 document.write(Date()) 打印当前日期时间 注意： Date()方法返回一个字符串，无法使用下面的各种方法，new Date（）返回一个日期对象，该对象才有下面的的各种方法 dateObj.getDate(): 返回月份中的某一天，返回值为1-31 dateObj.getDay(): 返回星期中的某一天, 0-6（0为周日） dateObj.getMonth(): 返回月份0-11 dateObj.getFullYear(): 以四位数字返回年份 dateObj.getTime(): 返回距离1970年1月1日之间的毫秒数 Date.parse(dateStr) ： 将一个日期字符串以毫秒形式返回，表示距离1970年的毫秒数，注意：前置为Date dateObj.toString(): 将Date对象转换为字符串，返回字符串 dateObj.toTimeString(): dateObj.toDateString(): ###HTML DOM Select对象 &lt;select&gt;标签每次出现一次，便创建了一个select对象 &lt;select&gt; &lt;option value=&quot;..&quot;&gt;..&lt;/option&gt;&lt;/select&gt; Select对象中存在options对象集合，select[0]表示select中第一个option选项 select[0] === select.options[0] 两种写法都可以 代码练习 最简单的时钟 十二小时制的时钟 日期的选择 日期的选择代码分析： 不同的月份对应不同的天数 rationalityCheck 函数 主要针对选项中29、30、31天操作，其中select对象存在options对象集合，select[28] select[29] select[30] 分别对应这三天 每次select改变后触发onchange事件，要执行该函数判断月份和天数的对应 格式化时间 123var now_date = new Date(); // 返回当前日期对象var selected_date = new Date(year,month-1,datee) // 返回当前日期对象var date_differ = now_date - selected_date; //返回毫秒数 日期对象相减得到的是毫秒数]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day22-Day24JavaScript里面的居民们]]></title>
    <url>%2F2018%2F06%2F26%2FDay22js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%B1%85%E6%B0%91%2F</url>
    <content type="text"><![CDATA[JavaScript中数据类型有 数字、字符串、布尔、对象、undefined、null以及array 值类型和引用类型值类型： 存储简单数据，复制的时候传递的是值 引用类型： 存储对象，复制的时候传递的是地址，并且可以动态添加属性 数据类型 数字 Number对象：创建Number对象的方法：var myNum = new Number(value); var myNum = Number(value) 前者（添加了new）是创建了一个Number对象，后者是将其当作函数调用将参数转换为数值，转换失败则返回NaN Number对象属性： Number.MAX_VALUE 返回最大的数 Number.NEGATIVE_INFNITY 负无穷大，溢出时返回该值 Number对象方法： NumberObj.toString(radix): 将数字对象实例转换为对应基数进制的字符串，可以指定基数（表示数字的进制，默认十进制），实例：num = 1314;num.toString(8) 返回“2442” 8进制2442 NumberObj.toFixed(num) : 可以把Number实例四舍五入取的小数位数为num位的数字 NumberObj.valueOf(): 将字符串返回数字 Math对象： 用于执行数学计算，JS中没有Math构造函数，内置了Math对象，其拥有属性和方法 Math对象属性： Math.PI Math对象方法: 注意：方法以Math开头 Math.abs(x): Math.ceil(x) : 向上舍入 Math.floor(x): 向下舍入 Math.max(x1,x2….) :返回最大数 Math.min(x1,x2….) :返回最小数 Math.pow(x,y): 返回x的y次幂 Math.random() 返回0-1随机数（包含0不包含1） Math.round(x) 四舍五入返回最接近的整数 字符串 String对象： string对象属性 stringObj.length: 返回字符串长度 string对象方法 stringObj.charAt(index): 返回index位置的字符 stringObj.charCodeAt(index): 返回index位置字符的编码 stringObj.concat(x1,x2,x3…): 将多个子串连接起来并返回 （通常使用+来代替该方法） stringObj.indexOf(检索字符串值，开始位置)： 返回检索字符串值的位置，不存在返回i-1，起始位置可以省略 stringObj.slice(start,end): 提取字符串中某个部分，并返回该部分值 stringObj.substr(start,length): 提取字符串某部分子串，与slice类似但是参数不同 stringObj.split(separator,how many): 将字符串按照一定的格式切割，返回切割后数组 stringObj.replace(regexp/substr,replacement) 对象 JS中所有事物都是对象 创建JS对象： 方法1：定义并创建对象的实例： 123&gt; person = new Object(); //创建了对象实例&gt; person.firstname = &quot;jack&quot;;//为对象实例添加属性&gt; 方法2： 使用对象构造器创建对象,并使用对象构造器创建实例 123456&gt; function person(firstname,lastname)&#123;&gt; this.firstname = firstname;&gt; this.lastname = lastname&gt; &#125;&gt; var myFather = new person(&quot;jack&quot;,&quot;hw&quot;);&gt; 数组 Array对象属性 length Array对象方法 arrayObj.concat(array1,array2,value1,value2…): 将多个数组拼接起来(其参数可以为数组也可以为值)，返回新数组 arrayObj.join() : 将数组内元素连接成一个字符串，并返回，不会改变原来的数组 arrayObj.slice(start,end): 从数组中返回选定的元素 ，注意string中也存在该方法 arrayObj.splice(index,howmany,item1,item2,…): 该方法是操作数组的万能方法，可以实现数组元素的添加或删除，该方法会改变原始数组 队列：只允许数据从前端删除，后端插入，就像排队一样，不允许插队，从后向前排列，所以先入队的数据必然先出队列 栈：只允许在一端添加或删除数据，栈就像一个盒子，数据看作书籍，一本一本放入盒子中，必然先放入盒子的书籍最靠底部，那么取出书的时候先放入的书籍必然最后取出，所以队列的特点是先进后出。 排序：arrayObj.sort(compareFunction) 默认根据 Unicode码位升序排列，该方法会改变原来的数组，当传入比较函数后，排序会根据传入函数的返回值，compareFunction(a,b) 小于0，a会排列b之前，等于0，a和b位置不变，大于0，a会在b之后 代码练习 数字相关的方法 字符串相关的方法 去除收尾空格函数 递归遍历对象属性 利用数组实现队列功能,队头在右侧 利用数组实现队列功能,队头在左侧 利用数组实现栈功能,队头在右侧 将对象转换为数组形式 将数组转换为对象形式,自己没想出来，参照别人的代码 others： 去除收尾空格函数：函数要求去除首位的半角或全角的空格，全角空格是在中文状态下的空格 去除字符串重复的地方： str[str.length] 该值不存在但是有值为undefined != 表达式两边的数据类型不一致时，会自动转换类型，再进行比较 ！== 不会进行类型转换，在比较时除了对值比较外，还比较两边的数据类型 遍历节点： 前序遍历（先根遍历，先序遍历） 中序遍历（中根遍历） 后序遍历（后根遍历） 前序遍历： 先根节点 后左子树 最后右子树 中序遍历： 左子树 根节点 右子树 后序遍历： 左子树 右子树 根节点]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day20与Day21和页面互动]]></title>
    <url>%2F2018%2F06%2F26%2FDay20%E4%B8%8E%E9%A1%B5%E9%9D%A2%E4%BA%92%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[HTML-DOM Text对象Text对象代表HTML表单中的文本输入域，在HTML中每次创建了一个input，那么就会生成一个Text对象，Text对象拥有属性和方法 Text对象属性 maxLength: 返回或设置文本域的最大字符数 disabled: 返回或设置文本域是否应该被禁用 defaultValue:返回或设置文本域的默认值 Text对象方法 blur() 失去焦点 focus() 获取焦点 select() 选择文本域中的内容 1document.querySelector(&quot;input&quot;).focus(); HTML-DOM-Button 对象HTML文档中，button标签每次出现一次，Button对象就会被创建 Button对象属性 disabled cssText的用法以及特点cssText本质就是批量设置HTML元素的style属性值 document.getElementById(&quot;p1&quot;).style.cssText = &quot;color:red;font-weight:bolder;&quot; 之前设置style属性值只可以每次设置一条：这样的代价是，每一条js代码，都会摧毁css样式生成一个新的css样式表，这样多条js代码，会增加浏览器开销，所以cssText的使用很有必要。 12document.getElementById(&quot;p1&quot;).style = &quot;color:red;font-weight:bolder;&quot;document.getElementById(&quot;p1&quot;).style = &quot;font-weight:bolder;&quot; 缺点： cssText每次被赋值后会将上一次的cssText值覆盖 ，所以在使用cssText中最好使用+= 操作符；cssText在不同浏览器中兼容性不同，在chrome中赋什么值就返回什么值，在IE中，返回值为属性变为大写，且去掉了最后一个分号;由于上述原因，cssText赋值操作为：document.getElementById(&quot;p1&quot;).style.cssText += &quot;: color:red;font-weight:bolder;&quot; 注意： 内容的前置分号，为了兼容IE，自动舍去最后一个分号的缺陷 JS事件机制DOM0级：同一个元素对于同一个事件只能绑定一个，例如多次声明click事件，希望点击第一次第二次分别执行不同的效果，但是效果是：第二次函数覆盖第一次的函数。 解除绑定： 由于上述的同一个事件只能绑定一次且后声明覆盖前者，那么解除绑定十分容易，将事件函数声明为null; 例如：解除点击事件btn.onclick = null DOM2级：支持同一个元素注册多个同种事件 chrome 注册： addEventListener(eventName,handlers,boolean) 事件名，处理函数、第三个值默认为false，表示在冒泡阶段调用事件处理程序，修改为true表示在捕获阶段使用事件处理程序 addEventListener(‘click’,function(){},false) 移除： removeEventListener(eventName,handlers,boolean) 使用注册函数绑定的事件需要使用移除函数来解绑，注意解绑时，参数要与绑定时参数一样。 IE 只支持事件冒泡，绑定及移除函数只有两个参数，分别为事件处理名称、事处理函数，这些方法默认绑定到事件冒泡， 所有只有两个参数 注册： attachEvent(事件处理名称，事件处理程序函数) attachEvent(‘onclick’,function(){…}) 移除： detachEvent(事件处理程序名称，事件处理函数) 事件委托：事件委托：就是利用事件冒泡原理实现的，事件从事件源（被点击的子元素）开始，逐步向上传播事件，触发父级元素的相应事件。 有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。 延迟执行函数setTimeout、clearTimeout注意： setTimeout(code,time) 这里的code为函数的时候需要加括号， setTimeout(&#39;func()&#39;,time) 需要添加引号 或者setTimeout(func,time) 没有引号同时函数也没有括号 如何写一个无限循环： 1234567891011121314function hiddenDiv()&#123; clearTimeout(timer); opacityVal -= 0.1; fadeDiv.style.opacity = opacityVal; btn.disabled = true; if(opacityVal &lt;= 0)&#123; clearTimeout(timer); btn.disabled = false; btn.textContent = "淡入"; hide = true; &#125;else&#123; setTimeout("hiddenDiv()",50); &#125; &#125; setInterval、clearIntervalcss sprite这是一种网页图片应用处理方式。将多个图片通过测量的方式组合成一张图片，利用background-position属性来确定目标背景图，减少了http请求，缺点是需要测量每一个背景的坐标位置，比较繁琐。 代码练习 输入内容后回车打印到控制台或输入过程中按Esc清空输入内容 遇到的问题 按键事件需要绑定到input中，onkeyup,注意event.which是chrome的键码，然而考虑兼容性，event.keyCode为IE的键码。键码表，注意其中的Enter，有两个Enter，一个为主键盘，一个为数字小键盘 [事件委托](https://codepen.io/younghw/full/YvjygQ/ setTimeout无限循环 setInterval无限循环]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day19找到那个DOM]]></title>
    <url>%2F2018%2F06%2F21%2FDay19%E6%89%BE%E5%88%B0DOM%2F</url>
    <content type="text"><![CDATA[DOMdocument-object-model：分为3个不同的部分，核心DOM针对任何结构化的文档模型，XML-DOM针对XML，HTML-DOM针对HTML 以下针对于HTML-DOM：HTML-DOM是关于如何获取、修改、添加或删除HTML元素的标准。 HTML-DOM中，所有事物都是节点 parentNode firstChild lastChild nextSibling previousSibling childNodes数组 HTML-DOM中，操作DOM节点方法有很多 getElementById appendChild(node) removeChild(node) HTML-DOM常用方法 推荐使用主流的选择元素方法：querySelecotor(选择器)该方法返回遇到的第一个符合条件的元素 querySelectorAll 以类数组形式返回所有匹配的元素； 创建元素：createElement createTextNode HTML-DOM中，属性有很多，其中nodeName为节点名称，nodeValue为节点值，其中元素节点值为undefined，文本节点值为文本本身，属性节点值为属性值 （每个HTML元素的属性为属性节点） nodeType为节点类型，只读，返回数字；childNodes属性是一个类数组，包含了父节点的所有子节点 childNodes[0]; textContent属性： 区别textContent和nodeValue： textContent：返回节点的文本内容，当有子节点的时候，获取子节点中的文本,忽略子节点本身 nodeValue: 返回节点的值，元素节点为undefined，文本节点为文本本身，但是该属性与前者不同 12345678910// &lt;div id=&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;// Get the text content:var text = document.getElementById(&quot;divA&quot;).textContent;// |text| is set to &quot;This is some text&quot;.// Set the text content:document.getElementById(&quot;divA&quot;).textContent = &quot;This is some text&quot;;// The HTML for divA is now:// &lt;div id=&quot;divA&quot;&gt;This is some text&lt;/div&gt; Window对象 获取窗口宽高： window.innerWidth window.innerHeight 代码练习 task-list]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day17-18JS基础]]></title>
    <url>%2F2018%2F06%2F19%2FDay17%E8%87%B318JS%2F</url>
    <content type="text"><![CDATA[JavaScript splict() 该方法将字符串按照特定的规则拆分为数组， 123&gt; var string = &quot;T-shirt:14.99&quot;;&gt; string.split(&quot;:&quot;);&gt; slice(start,end) 截取字符串的某个子串 从start开始到end-1处结束 函数作用域和冲突： 12345&lt;script src=&quot;first.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;second.js&quot;&gt;&lt;/script&gt;&lt;script&gt; greeting();&lt;/script&gt; second.js因为是后引入的，所以first.js中变量函数相同的将会覆盖 事件 事件对象： event 或 e 事件对象表示绑定事件的元素本身 event.style.background=”red” 给元素设置背景色 阻止默认事件： e.preventDefault() 阻止事件冒泡： e.stopPropagation() 当然我们可以利用事件冒泡机制来实现事件委托 event中有很多属性，其中event.target指向了绑定事件元素本身。 关于setAttribute() 该方式设置元素的属性，setAttribute(&#39;class&#39;,xxx) 但是没有setAttribute(&#39;background&#39;,xxx) 因为background是元素style的属性，正确使用为：element.style.background = &#39;grb(xxx)&#39;; 练习代码 Decimal-system-to-binary-system Decimal-system-to-binary-system2 为你填坑：以为这样就完事了？ 那就错了，注意要提前取出数组长度 123456&gt; if(arr.length &lt; binLength)&#123;&gt; for(var i=0;i&lt; binLength-arr.length;i++)&#123;&gt; arr.unshift(0);&gt; &#125;&gt; &#125;&gt; 正确代码： 1234567&gt; var initLength = arr.length;&gt; if(arr.length &lt; binLength)&#123;&gt; for(var i=0;i&lt; binLength-initLength;i++)&#123;&gt; arr.unshift(0);&gt; &#125;&gt; &#125;&gt; Guess-3-game multiplication-9X9-table 简历招呼效果 12var myDate = new Date();var hour = myDate.getHours(); //返回小时格式]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day16感受JS乐趣]]></title>
    <url>%2F2018%2F06%2F18%2FDay16JS%2F</url>
    <content type="text"><![CDATA[JavaScript 脚本语言: 是一种不需要编译的编程语言，传统的编译型编程语言（C Java）需要先编译成二进制机器码，再交给机器执行，脚本语言写出的代码就是最终执行文件，效率高。 在JS中，应用程序编程接口APIs会提供很欠打的功能，分为两类: 浏览器APIs，存在于浏览器中，包括文档对象模型API(DOM)、地理位置API、画布等API 第三方APIs：默认没有安装到浏览器内，可以从网络上获取。如谷歌地图API JavaScript和ECMAScript的区别： ECMAScript是一种规范，定义了JavaScript语言规则 JavaScript是一种解释型脚本语言，遵循了ECMAScript规范 ECMAScript6是一种第六版新规范，相对于ECMAScript规范有显著的变化和改进，同义词：ES6、ES2015、ECMAScript 2015 JavaScript语法 document.write(...) 向文档流中写入内容，注意： 在文档加载完毕后执行该语句，整个HTML页面将会被重写 声明变量类型: 在声明新变量时，可以使用new关键字来声明其类型,js变量均为对象，当声明了一个变量时，就创建了一个新对象。 疑问：什么时候需要声明变量类型？ var x = new Number; var y = new Boolean; 在js中所有事物都是对象，string、number、array 练习 加减乘除运算 简历 简单猜数字小游戏]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day12-15做一个复杂的页面]]></title>
    <url>%2F2018%2F06%2F17%2FDay12and15%E7%9B%B8%E5%AF%B9%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[页面要求 最左侧一列要求自适应浏览器高度，左上面4个按钮相对浏览器左上角固定位置，左下方两个按钮相对浏览器左下角固定位置 左侧第二列(蓝色背景色)导航列固定宽度，高度也是自适应浏览器高度，最下面的Monthly Goals部分的内容相对浏览器下边固定位置 整个白色区域自适应宽度，右上方的人脸，名字部分相对浏览器右上角固定位置 白色区域左侧列固定宽度，右侧列自适应宽度 实现过程中遇到并解决的问题 实现滚动效果，但是要隐藏滚动条 隐藏滚动条 解决方案： 12345&lt;div class="wrapper"&gt; &lt;div class="inner-wrapper"&gt; 很多内容，高度会超出inner-wrapper &lt;/div&gt;&lt;/div 内层容器：定义其宽度大于外层容器17px（这里17px为滚动条宽度），设置内层容器overflow:auto 当其内容高度高于内层容器时，自动产生滚动条。 外层容器：设置其overflow:hidden ,隐藏内层容器的滚动条。（因为内层宽度大于外层宽度17px） 最下面的Monthly Goals部分固定在浏览器下方（相当于sticky footer布局） 解决方案： 有多种解决方案，固定高度、flexbox等方案，我在练习中使用的是固定高度解决方案 固定高度：sticky-footer-calc 123456&lt;div class="wrapper"&gt; &lt;div class="inner-wrapper"&gt; 很多内容... &lt;/div&gt; &lt;div class="footer"&gt;Footer&lt;/div&gt;&lt;/div&gt; 其实现原理很简单，首先确定footer 的高度，inner-wrapper的min-height为calc(100% - footer的高度),确保在inner-wrapper没有内容时，高度仍会撑起整个容器高度。 缺点是：当布局完成后，改变footer高度影响布局 flexbox布局： sticky-footer-flexbox 优点：可以随意改变footer的高度，布局不受影响。 calc() 使用注意：运算符之间必须用空格隔开 calc(100% - 50px) 代码地址相对复杂的页面]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>切图</tag>
        <tag>基本布局</tag>
        <tag>写一个网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day9-11完成一个简单页面]]></title>
    <url>%2F2018%2F06%2F15%2FDay9and11%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[切图基础传统的切图方法 利用参考线把准备切的图标框选出来 使用切片工具来切出图标 选择存储为web所用合适，保存为png-24格式，注意保存的时候切片要选择所有用户切片 自定义切图专用工作区 信息面板：该面板会显示选取的像素宽高，以及文档的宽高 字符面板：该面板会显示以psd保存的web中字体样式及大小 写一个网页由于给出的是一个psd及jpg文件，图片尺寸达到了1600x6272 ，然而屏幕宽度只有1366px，所以第一步产生了很大的困惑，做起来很纠结。 题目要求按照设计尺寸写web,但是实际尺寸很大，于是我进行了一些缩放 布局用的比较少，只用到了flex布局，用于多列布局 代码中存在冗余，比如container样式可以复用 写这个网页用了接近两天时间，最主要是尺寸问题纠结了好久，所以只把基本布局完成了，尚未写导师浮动效果，后期会填上这个坑的 文字两端对齐效果太差 后期 代码优化，减少冗余 阅读编码规范 将代码补齐，浮动效果，文字排版 参考这位同学完全实现了各项要求 梁嘉欣]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>切图</tag>
        <tag>基本布局</tag>
        <tag>写一个网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day7和8学习布局]]></title>
    <url>%2F2018%2F06%2F12%2FDay7%E5%92%8C8%E5%AD%A6%E4%B9%A0%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[基础知识定位position relative 相对定位：占据正常文档流 absolute 绝对定位：脱离文档流，这里的top left right bottom指的是偏离当前被定义为relative或absolute父元素的距离 tips： position：absolute;left:120px;right:120 定义了一个区域，宽度未知 fixed 固定定位：脱离文档流 相对于当前视窗定位 弹性布局Flexbox弹性布局的优点：1. 可以使父容器内块级元素垂直居中 2.使子元素均分父元素宽度 3.多列布局每一列采用相同高度，即使每列内容多少不一样。 flex-direction 定义主轴方向，默认为row flex-wrap flex项是否换行（当子项总宽度超过父元素的时候是否换行），默认为不换行 缩写：flex-flow: row wrap 这是主轴方向和是否换行的缩写形式 flex:flex-grow flex-shrink flex-basis flex-grow为必须值 后两个为可选值 该属性默认值为(0 1 auto) flex:1 200px 每个flex项首先给出200px的可用空间，然后剩余的空间根据分配的比例共享，当空间过小的时候会等比例缩小 布局效果 align-items 定义flex项在交叉轴上的位置 justify-content 定义flex项在主轴上的位置 order 定义项排列顺序 使用该属性后总结： flex默认会将所有子项在一行内显示，当子项总宽度超过父元素宽度时，子元素等比例压缩，保证不会超过父元素，这时候子项宽度不会等于定义的flex-basis：xxx，假若定义flex:0 0 200px 那么子项不会被压缩，子元素总宽度超过了父元素宽度，定义flew-wrap:wrap 子项就会换行显示，保证不超出父项。 float浮动原理float的设计初衷是实现文字环绕效果 float：具有包裹性，当div设置float后，其宽度会自动调整为包裹住内容宽度。 &lt;div style=&quot;border:2px solid blue;padding:2px;float:left&quot;&gt;&lt;/div&gt; 网页中元素对齐方式水平居中： 子元素为行内元素：text-align:center; 子元素为定宽块级元素：利用margin:0 atuo; 子元素为不定宽块级元素：将子块级元素变为行内元素，利用方法1； 垂直居中： 子元素为块级元素且高度未定：设置父元素样式display:table-cell;vertical-align:middle 通过改变元素的display 子元素为行内元素：利用line-height 水平垂直居中： 子元素为行内元素: text-align:center;line-height:父元素高度 子元素为块级元素：父元素设置text-align:center;vertical-align:middle;display:table-cell 子元素设置display:inline-block; 左右两栏布局 有些布局感觉特别好：参考文档 float+BFC方法：左侧栏目浮动，右侧栏目变成BFC，由于BFC不会和浮动元素重合，所以实现了左右两栏布局 123456789101112.left&#123; float:left; width:150px; border:5px solid #ff6c60; margin-right:20px;&#125;.right&#123; margin-left:0; margin-left:20px; border:5px solid #ff6c60; overflow:auto;&#125; 经典布局圣杯布局(Holy Grails) 圣杯布局是三列布局，利用负margin技术，将两侧边栏偏移到对应位置上。 圣杯布局代码： 12345&lt;div class="container"&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .container&#123; width:80%; margin:0 auto; box-sizing:border-box; padding-right:150px; /*创建padding，该padding区域是两侧边栏的位置*/ padding-left:200px; border:1px solid #ccc; &#125; .container::after&#123; content:''; display:block; clear:both; &#125; .main,.left,.right&#123; float:left; position:relative; &#125; .main&#123; width:100%; min-height:100px; background:#ccc; &#125; .left&#123; width:200px; min-height:150px; background:pink; margin-left:-100%; /*margin 百分数是相对于父元素的宽度*/ /*这里是margin-left*/ left:-200px; /*产生偏移 移动到padding空出的位置*/ &#125; .right&#123; width:150px; min-height:200px; background:orange; margin-right:-150px; /* 这里是margin-right*/ &#125;&lt;/style&gt; 双飞翼布局双飞翼布局：先安置好身体，在把子列和附加列安放到正确位置 双飞翼代码： 1234567&lt;div class="bird"&gt; &lt;div class="main"&gt; &lt;div id=main-content&gt;主列&lt;/div&gt; &lt;/div&gt; &lt;div class="sub"&gt;子列&lt;/div&gt; &lt;div class="extra"&gt;附加列&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; .bird&#123; width:80%; margin:0 auto; min-height:200px; border:1px solid #ccc; &#125; .bird::after&#123; content:""; display:block; clear:both; &#125; .main,.sub,.extra&#123; float:left; &#125; .main&#123; width:100%; min-height:180px; background:#ccc; &#125; .sub&#123; width:190px; margin-left:-100%; background: pink; &#125; .extra&#123; width:150px; margin-left:-150px; /*注意：这里是margin-left*/ background: orange; &#125; /*以上代码将布局基本完成，但是左右侧边栏遮盖了部分main，还需要调整main*/ /*将main中内容放入一个块中单独调整*/ #main-content&#123; margin:0 150px 0 190px; &#125;&lt;/style&gt; 几个练手布局代码 不给块级子元素设置宽度，那么块级子元素宽度会自动占据父元素剩余的空间，假若设置了块级子元素宽度为100%，若存在其他子元素，那么会溢出父元素宽度 浮动布局：主体必须放在后面 代码列表 圣杯布局 双飞翼布局 作业]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day5和6三种简历效果实现]]></title>
    <url>%2F2018%2F06%2F11%2FDay5%E5%92%8C6%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[技术支持主要包括盒模型、浮动、浮动布局、清除浮动副作用的几种方法等内容。 盒模型 box-sizing:content-box|border-box 默认为content-box 浮动浮动原理：浮动元素会脱离文档布局流，吸附到其父元素的左边/右边。在正常布局中位于该元素之下的内容，此时会围绕浮动元素，填满其右侧/左侧的空间。 清除浮动or闭合浮动： 以前没有意识到这个问题，清除浮动即为clear，解决元素浮动，后续元素不能正确定位的问题，但是浮动元素内部塌陷问题并没有得到解决； 闭合浮动 使浮动元素闭合，消除浮动带来的负作用（父元素塌陷问题，后续元素定位错误问题），我们一般想要达到第二种效果，既要解决父元素问题同时也要解决后续元素定位问题，所以我们应该把它称为闭合浮动 以下代码是浮动负作用、清除浮动、闭合浮动的效果 codepen清除浮动与闭合浮动 三种简历的实现项目地址]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day4背景边框列表链接和更复杂的选择器]]></title>
    <url>%2F2018%2F06%2F10%2FDay4%E8%83%8C%E6%99%AF%E8%BE%B9%E6%A1%86%E5%88%97%E8%A1%A8%E9%93%BE%E6%8E%A5%E5%92%8C%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.背景背景的范围：默认背景范围是content+padding+border，假若背景图片宽高大于给定的区域，那么该背景图片就会产生切割，默认是从border外侧切割，切割后就是背景。 改变背景的默认范围通过改变background-clip的属性值，可以改变背景的作用范围。background-clip:border-box|padding-box|content-box|text border-box 背景从border外侧切开，背景范围为border+padding+content padding-box 背景从padding外侧切开，背景范围为padding+content content-box 背景从content外侧切开，背景范围为content text 从文字向外切除，背景只覆盖文字范围，利用该方法可以实现遮罩效果（之在文字处有背景） 注意:该text属性值只有webkit支持，所以在写该属性值的时候需要添加前缀 -webkit- 1234567891011121314151617&gt; .div&#123;&gt; width:200px;&gt; height:100px;&gt; border:10px solid transparent;&gt; padding:20px;&gt; margin:10px auto;&gt; background-image:url(https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3249243410,892137105&amp;fm=27&amp;gp=0.jpg);&gt; font-size:50px;&gt; /* text属性值必须添加-webkit-前缀 */&gt; -webkit-background-clip:text;&gt; color:transparent;&gt; font-weight:800;&gt; &#125;&gt; &lt;div class="div"&gt;&gt; 文字遮罩效果&gt; &lt;/div&gt;&gt; 背景基础 背景颜色 背景图像 背景重复 background-repeat 设置背景图片的重复方式 背景位置: background-position：x y; 设置背景图片在背景上的位置,值可以取关键字left center right bottom 背景图像：渐变background-image:linear-gradient(to bottom,orange,yellow); 背景附着background-attachment:scroll|fixed|local scroll : 背景跟随内容滚动 fixed: 元素内容滚动，背景不会滚动 背景尺寸background-size：可以调整背景图片的大小，可以将图片大小调整为区域的宽高，能够适合该区域。 注意：background-size是调整背景图片大小的 background-clip是定义背景范围，两者不同，不要混淆。 2.边框样式 border-image-source:url(...) borderimage-slice:声明left right top bottom四条切割线的偏移量 border-image-repeat： 声明5-8区域的重复方式 值为stretch | repeat | round | space 推荐使用round 可以比较智能的将图片用最可能小的缩放充满边界 具体介绍： 图片介绍边框样式]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day3让简历有点色彩]]></title>
    <url>%2F2018%2F06%2F09%2FDay3%E8%AE%A9%E7%AE%80%E5%8E%86%E6%9C%89%E7%82%B9%E8%89%B2%E5%BD%A9%2F</url>
    <content type="text"><![CDATA[CSS工作原理先加载HTML，将HTML解析为DOM，之后解析CSS，并将CSS添加到对应的DOM节点上。 CSS选择器css选择器种类繁多，归结起来可以分为：简单选择器、属性选择器、伪类、伪元素、组合器、多用选择器 简单选择器主要包括元素名选择器、id选择器、class选择器、通用选择器(*) 属性选择器属性选择器是利用(方括号)根据元素的属性和属性值来匹配元素 属性存在选择器: [attr] [attr=val] [attr~=val] 选择具有某个属性或属性等于特定值的元素，其中[attr~=val] 选择具有某个具有某种属性并且值为多个，val只是其中一个 12345&gt; &lt;ul&gt;&gt; &lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/CSS"&gt;CSS&lt;/a&gt;&lt;/li&gt;&gt; &lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/HTML"&gt;HTML&lt;/a&gt;&lt;/li&gt;&gt; &lt;/ul&gt;&gt; [href^=https]{} 属性值子串选择器: [attr^=val] [attr$=val] [attr*=val] 其中[attr*=val]表示attr属性值包含子串val就可以被选中 前两种选择器的区别： 第一种：[attr=val] 只有当元素的attr属性值为val就会被选中 第二种：[attr*=val] 当元素的attr属性值存在子串val的时候就会被选中 伪类什么是伪类，其实现效果等价为给元素添加了一个类名，但是没有类名的存在，所以称为伪类 具体记录几个容易记混的伪类：(这里的E指的都是子元素) E:nth-of-type(n) : 选择父元素的第n个子元素E 1234567&gt; &lt;div class="demo"&gt;&gt; &lt;p&gt;p1&lt;/p&gt;&gt; &lt;p&gt;p2&lt;/p&gt;&gt; &lt;span&gt;span1&lt;/span&gt;&gt; &lt;p&gt;p3&lt;/p&gt;&gt; &lt;/div&gt;&gt; p:nth-of-type(3) 这里p3将会选中，因为父元素demo下的子元素一共有三个p元素，其中第三个为p3 E:nth-child(n) : 选择父元素下的第n个子元素E，当第n个子元素不是E的时候，该选择器无效 1234567&gt; &lt;div class="demo"&gt;&gt; &lt;p&gt;p1&lt;/p&gt;&gt; &lt;p&gt;p2&lt;/p&gt;&gt; &lt;span&gt;span1&lt;/span&gt;&gt; &lt;p&gt;p3&lt;/p&gt;&gt; &lt;/div&gt;&gt; p:nth-child(3) : 该选择器不会选中p3，因为在demo中第三个子元素为span不是p元素，要想选中p3需要使用p:nth-of-type(3) E:last-child : 选择父元素的最后一个子元素E，当最后一个子元素不是E的时候则不会生效 伪元素什么是伪元素：伪元素现实了给页面添加一个元素的效果，比如::after 效果是在选中元素后添加内容 具体的伪元素： ::before ::after ::first-line ::first-letter ::selection ::backdrop 组合器 A &gt; B B是A的直接子节点 A + B B是A的兄弟节点，B必须是A的紧邻的下一个节点 A ~ B A与B为兄弟节点，且B在A之后，可以是任意位置 CSS文字样式CSS中文字样式包括：文字字体样式，文字布局风格。这里主要列举了几个相对重要且自己平时使用频率较低的属性 文字字体样式主要关于字体的样式，采用什么类型的字体、字体的大小、字体是否加粗显示 text-transform: 将文字进行转换可以转换为首字母大写、全部转换为小写等效果，值为none|uppercase|lowercase|capitalize|full-width text-decoration: 该属性可以一次接受多个值，为字体添加多种样式，值为:none|underline|overline|line-through text-shadow:x y r color 文字阴影效果也是文字字体样式 文字布局风格主要关于文字的布局，如行高、文本对齐方式 text-align: left|right|center|justify line-height letter-spacing 为每个字母之间的距离 word-spacing 为每个单词之间的距离]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day2做一个在线简历]]></title>
    <url>%2F2018%2F06%2F08%2FDay2%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[阅读延伸W3CSchool的HTML教学 在线教程 &lt;a href=&quot;....&quot;&gt;This is a link&lt;/a&gt; 区别href与src : 参考 href: 表示超文本引用，用于引用网络资源的位置，可以通过锚点可以跳转到目标资源上，当然也可以引入css，常用在link a 标签上，&lt;link href=&quot;reset.css&quot; rel=&quot;stylesheet&quot;/&gt;浏览器会从对应的地址上下载css文件，下载过程中，并不会停止对当前文档的处理，这也是*建议使用link引用css而不使用@import加载css的原因 src ： 即source，是页面中不可缺少的一部分，src指向的内容会嵌入到文档中标签所在位置，常用在script img 上。 &lt;script src=&quot;demo.js&quot;&gt;&lt;/script&gt; 该标签会引入demo.js文件中js代码，替换此处的script标签 总而言之： href表示当前文档与引用资源之间建立联系，src用于替换当前元素 HTML图像： &lt;img src=&#39;图片地址&#39; width=&#39;66&#39; height=&#39;66&#39;&gt; 定义img图像需要将尺寸以标签属性的形式声明 HTML标签及标签内属性大小写不敏感，所以在自定义标签的时候可以使用中划线的方法 &lt;my-tag title=&#39;this is my tag&#39;&gt;&lt;/my-tag&gt; 适用于大多数标签的常用的几个HTML属性：class id style title 引用标签：较短语句的引用&lt;q&gt;...&lt;/q&gt; 较长的引用&lt;blockquote&gt;...&lt;/blockquote &lt;q&gt;会将元素内容前后添加引号来在页面上显示 &lt;blockquote&gt; 会将元素内容进行缩进来在页面上显示 &lt;a&gt;标签定义锚点，在同一文章内可以利用锚点跳转,使用name来定义锚点 1234&gt; &gt; &lt;a name="tips"&gt;基本的注意事项&lt;/a&gt;&gt; &gt; ....&gt; &gt; &lt;a href="#tips"&gt;跳转到注意事项&lt;/a&gt;&gt; &gt; 注意： 在使用链接标签链接地址为一个文件夹的时候要注意href的地址正确写法 1234567&gt; &lt;a href="http://www.w3school.com.cn/html"&gt;该链接会产生两次HTTP请求&lt;/a&gt;&gt; &lt;!-- 如果子文件夹的末尾没有正斜杠，就会产生两次HTTP请求 --&gt;&gt; &lt;!-- 应为当子文件夹没有正斜杠，服务器会添加正斜杠到该地址，另外创建了一个新请求 --&gt;&gt; .... &gt; &lt;!-- 正确写法 --&gt;&gt; &lt;a href="http://www.w3school.com.cn/html/"&gt;跳转到注意事项&lt;/a&gt;&gt; &lt;img&gt; 创建图像映射，图像标签的usemap属性来定义图像映射,该属性值为&lt;map&gt;元素的name或id属性值 图像映射： 一个图像建立多个链接，点击图像的不同区域跳转到不同的链接地址 1234567&gt; &gt; &lt;img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1528507118&amp;di=52579fb03028f32458941a0083d04dc5&amp;src=http://img3.duitang.com/uploads/item/201509/04/20150904014041_Lw8Cv.jpeg" alt="" width="166" height="166" usemap="#my-map"&gt;&gt; &gt; &lt;!-- img标签通过usemap属性来链接到map标签 --&gt;&gt; &gt; &lt;map name='my-map' id="my-map"&gt;&gt; &gt; &lt;area shape="circle" coords="0,0,30" href="https://baidu.com/"/&gt;&gt; &gt; &lt;area shape="rect" coords="0,88,166,166" href="http://www.w3school.com.cn/"/&gt;&gt; &gt; &lt;/map&gt;&gt; &gt; area 标签中coords属性：值为像素，起点为图片的左上角 框架： &lt;frameset&gt; 标签用于定义如何分隔窗口，其中属性值rows/columns定义了每行或每列占据屏幕的面积,&lt;frame&gt;标签用于定义每个框架 12345&gt; &gt; &lt;frameset cols="25%,75%"&gt;&gt; &gt; &lt;frame src="frame_a.html"&gt;&gt; &gt; &lt;frame src="frame_b.html"&gt;&gt; &gt; &lt;/frameset&gt;&gt; &gt; 实现了页面分隔为左右两部分 内联框架：指在网页内显示网页,使用&lt;iframe&gt;标签 12&gt; &gt; &lt;iframe src=&quot;...&quot; width=&quot;80&quot; height=&quot;100&quot;&gt;&lt;/iframe&gt;&gt; &gt; &lt;noscript&gt; 该标签用于在浏览器不支持js的时候显示相应的文本 &lt;noscript&gt;你的浏览器不支持js&lt;/noscript&gt; HTML中的实体字符 在HTML中，某些字符有特殊意义,比如&lt; 代表标签的开始，但是有时候需要使用特殊字符，这里引入了实体字符，其中&amp;nbsp 代表 空格 ​]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day1为什么学前端]]></title>
    <url>%2F2018%2F06%2F08%2FDay1%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[学习前端断断续续接近半年，终于赶上这次百度前端技术学院开课了，趁机会系统学习一下前端基础知识。 几个基础的概念 HTML5 : 这是HTML的新标准，其中添加好多新标签与属性，目前开发者正热情的推广该版本 XML : 可扩展标记语言，用于传输和存储数据 XHTML : 是HTML的严格版本，该标准对语法要求严格 XML 与 XHTML HTML区别： XML 是用于存储和传输数据的，其重点为数据的内容；XHTML HTML是用于显示信息的，其重点为数据的展示。 后端的几个概念： 只是粗略的了解node php 还尚未深入。 待续……]]></content>
      <categories>
        <category>百度前端技术学院2018</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue过渡效果]]></title>
    <url>%2F2018%2F06%2F02%2Fvue%E8%BF%87%E6%B8%A1%E5%8F%8A%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[Vue动画使用自带的过渡类名类似于Vue过渡，同样具有那六个类名，v-enter v-enter-to v-enter-active v-leave v-leave-to v-leave-active 在其中定义元素过渡时候的动画 1234567891011121314151617181920212223242526272829303132...&lt;style&gt; .cartoon-enter&#123; background:orange; &#125; .cartoon-enter-active&#123; animation: cartoon 5s ; &#125; .cartoon-leave-active&#123; animation: cartoon 5s reverse; &#125; @keyframes cartoon&#123; 0%&#123; transform:scale(0); &#125; 50%&#123; transform:scale(1.5); &#125; 100%&#123; transform:scale(1); &#125; &#125;&lt;/style&gt;...&lt;div id="app1"&gt; &lt;button @click="show = !show"&gt;&lt;/button&gt; &lt;transition name="cartoon"&gt; &lt;div style="width='200' height='200'"&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/div&gt; 这里的六个class是根据transition的name属性来自动生成的，通过给指定的class在style标签内定义过渡动画即可。 v-enter : 目标元素进入过渡开始时一瞬间的状态 v-enter-to ： 目标元素在过渡结束时的状态 v-enter-active ： 目标元素在整个过渡阶段的状态 v-leave ： 目标元素离开过渡开始时一瞬间的状态 v-leave-to ： 目标元素在过渡结束时的状态 v-leave-active ：目标元素在整个过渡阶段的状态 自定义过渡类名（需要借助特性）在transition中有以下几个特性来定义，这些特性可以指定过渡类名，可以直接引入各种动画库的类名，免去了自定义动画样式的步骤 六个特性： enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 这里引入animate库，直接将动画类名引入即可 12345678...&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.5.2/animate.min.css"&gt;...&lt;transition name="xxx" enter-active-class="animated tada" leave-active-class="animated bounceOutRight"&gt; &lt;div&gt; ... &lt;/div&gt;&lt;/transition&gt; 多个组件的过渡由于过渡动画enter和leave是同时进行的，当有多个组件的时候，可能一个组件的退出与一个组件的进入同时发生的，造成混乱效果，引入mode选项，可以规定谁先进行 12345678910111213141516171819202122232425262728293031&lt;div id="app1"&gt; &lt;button @click="change"&gt;toggle&lt;/button&gt; &lt;transition name="cartoon" enter-active-class="animated bounceIn" leave-active-class="animated bounceOut" mode="out-in"&gt; &lt;component :is="select"&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; new Vue(&#123; el: '#app1', data: &#123; select: 'component1', &#125;, methods:&#123; change()&#123; if(this.select==='component1')&#123; this.select='component2' &#125;else&#123; this.select='component1' &#125; &#125; &#125;, components:&#123; 'component1':&#123; template: `&lt;div&gt;第一个组件&lt;/div&gt;`, &#125;, 'component2':&#123; template: `&lt;div&gt;第二个组件&lt;/div&gt;` &#125; &#125;&#125;)&lt;/script&gt; CSS3中动画animation: 动画名|持续时间|动画速度曲线|动画开始之前的延迟 动画播放次数 是否反向播放动画 默认值：animation: none 0 ease 0 1 normal; 必须值： animation: 动画名称 持续时间 animation-name animation-duration animation-timing-functions animation-delay animation-iteration-count animation-direction 123@keyframes animation-name&#123; ...&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue过渡效果]]></title>
    <url>%2F2018%2F06%2F01%2Fvue%E8%BF%87%E6%B8%A1%2F</url>
    <content type="text"><![CDATA[纠结好久的过渡问题终于解决了，vue过渡实现的过程从头到尾梳理了一遍，嗯，过程很清楚，赶快把思路记录下来，便于以后参考 v-enter : 目标元素进入过渡开始时一瞬间的状态 v-enter-to ： 目标元素在过渡结束时的状态 v-enter-active ： 目标元素在整个过渡阶段的状态 v-leave ： 目标元素离开过渡开始时一瞬间的状态 v-leave-to ： 目标元素在过渡结束时的状态 v-leave-active ：目标元素在整个过渡阶段的状态 所有的过渡样式只会在过渡过程中有效 opacity: 默认值为1 表示完全不透明 （opacity：不透明度 1表示完全不透明 0表示完全透明） 过渡效果实例实例：效果为点击按钮div区域淡入淡出 12345678910111213141516171819202122232425262728293031323334...&lt;style&gt; .div1&#123; width:200px; height:200px; background:orange; &#125; .fade-enter&#123; opacity:0; &#125; .fade-enter-active&#123; transition:opacity 5s; &#125; .fade-leave-active&#123; opacity:0; transition:opacity 5s; &#125;&lt;/style&gt;...&lt;div id="app"&gt; &lt;button v-on:click='show = !show'&gt;toggle&lt;/button&gt; &lt;transition name="fade"&gt; &lt;div v-if="show" class="div1"&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt;...&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; show:true &#125; &#125;)&lt;/script&gt; 代码分析: 1234567891011121314151617&lt;style&gt; .div1&#123; width:200px; height:200px; background:orange; &#125; .fade-enter&#123; opacity:0; &#125; .fade-enter-active&#123; transition:opacity 5s; &#125; .fade-leave-active&#123; opacity:0; transition:opacity 5s; &#125;&lt;/style&gt; 当点击按钮图片出现的时候，我们希望它不要立刻出现，要将其完全透明，利用过渡效果，逐渐出现；当点击按钮图片消失的时候，我们希望它不要立刻消失，要利用过渡效果使其逐渐消失。 div进入时候，fade-enter 在进入一瞬间将其设置为全透明，由于div进入的状态最终为不透明，所以fade-enter-to可以不用设置，整个进入过渡中fade-enter-active采用将透明度作为过渡效果并持续5秒 div离开时候，因为div是不透明的，那么fade-leave 可以不用设置，在过渡结束的时候需要将其设置为完全透明，此时可以使用fade-leave-to来定义过渡结束时的状态，但是也可以将其写在fade-enter-active中，整个离开过渡中fade-enter-active采用将透明度作为过渡效果并持续5秒 将style代码也可以改写为: 12345678910111213141516171819202122&lt;style&gt; .div1&#123; width:200px; height:200px; background:orange; &#125; /*淡入*/ .fade-enter&#123; opacity:0; &#125; .fade-enter-to&#123;opacity:1;&#125; /*fade-enter-to也可以不用，因为最终状态同样为不透明*/ .fade-enter-active&#123; transition:opacity 5s; /*在div进入的整个过程中采用的过渡效果*/ &#125; /*淡出*/ .fade-leave&#123;opacity:1&#125; /*fade-leave也可以不用，因为离开过渡开始的一瞬间div本身就是完全不透明的*/ .fade-leave-to&#123;opacity:0&#125; .fade-leave-active&#123; transition:opacity 5s; /*在div离开的整个过程中采用的过渡效果*/ &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue注册组件步骤]]></title>
    <url>%2F2018%2F06%2F01%2Fvue%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[组件是可复用的Vue实例，组件与实例类似也是接受相同的选项，但是仅有根实例才会有el这样的选项，组件中data选项必须是函数的形式与根实例不同。 1.注册组件基础写法注册全局组件 Vue.extend(options) 创建了一个子类，参数为组件选项组成的对象 Vue.component(‘组件名’，组件的构造器) 实例化组件 （组件需要挂载到某个Vue的实例下，否则不会生效） 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; let component1 = Vue.extend(&#123; template: `&lt;div class=&quot;base-style class1&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data()&#123; return&#123; msg : &apos;this is my-component &apos; &#125; &#125; &#125;); Vue.component(&quot;my-component&quot;, component1); new Vue(&#123; el: &quot;#app&quot;, &#125;)&lt;/script&gt; 注册局部组件 创建一个组件构造器 Vue.extend() 在vue实例下的components选项下将组件注册为局部组件并挂载到该Vue实例上 components:{‘组件名’：组件的构造器} 2.注册组件语法糖注册全局组件Vue.component(&#39;组件名&#39;，{/*......*/}) 传入一个选项对象，这会自动调用Vue.extend 12345678Vue.component(&apos;my-component&apos;,&#123; template: `&lt;div class=&quot;base-style class1&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data()&#123; return&#123; msg : &apos;this is my-component &apos; &#125; &#125;&#125;) 组测局部组件需要在vue实例的components选项中注册 12345678910111213new Vue(&#123; el: &apos;#app&apos;, components:&#123; &apos;my-component&apos;:&#123; template: `&lt;div class=&quot;base-style class1&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data()&#123; return&#123; msg : &apos;this is my-component &apos; &#125; &#125; &#125; &#125;&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中绑定class的几种方法]]></title>
    <url>%2F2018%2F05%2F31%2FVue%E4%B8%AD%E7%BB%91%E5%AE%9Aclass%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[vue中元素绑定class1.使用对象绑定1234567891011121314151617181920212223242526272829303132...&lt;style type="text/css" media="screen"&gt; .base-style&#123; height:100px; width:100px; border: 1px solid #ccc; &#125; .class1&#123; background-color: orange; &#125; .class2&#123; border-radius: 50%; &#125;&lt;/style&gt;...&lt;div id="app"&gt; &lt;div class="base-style" :class="&#123;class1:classValue1,class2:classValue2&#125;"&gt;&lt;/div&gt; &lt;div class="base-style" :class="classObj"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; classValue1:true, classValue2:true, classObj:&#123; class1: true, class2: false, &#125; &#125; &#125;)&lt;/script&gt; 最终渲染为： 12&lt;div class=&quot;base-style class1 class2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;base-style class1 &quot;&gt;&lt;/div&gt; 2.使用数组绑定1234567891011121314...&lt;div id="app"&gt; &lt;div class="base-style" :class="[classStyle1,classStyle2]"&gt;&lt;/div&gt;&lt;/div&gt;...&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; classStyle1: 'class1', classStyle2: 'class2', &#125; &#125;)&lt;/script&gt; 最终渲染为：&lt;div class=&quot;base-style class1 class2&quot;&gt;&lt;/div&gt; 3.将class绑定到组件上12345678910111213141516171819...&lt;div id="app"&gt; &lt;my-components class="base-style"&gt;&lt;/my-components&gt;&lt;/div&gt;...&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; classStyle1: 'class1', classStyle2: 'class2', &#125;, components:&#123; 'my-components':&#123; template: '&lt;div class="class1 class2"&gt;&lt;/div&gt;' &#125; &#125; &#125;)&lt;/script&gt; 最终渲染为： 123&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;base-style class1 class2&quot;&gt;&lt;/div&gt;&lt;/div&gt; 组件上的class将会传递到组件template内 &lt;my-component class=&quot;base-style&quot;&gt;&lt;/my-component&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中事件监听与触发]]></title>
    <url>%2F2018%2F05%2F31%2FVue%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[v-on事件监听v-on监听某个事件，当事件触发后会执行相应的操作 以下为一个事件监听实例，具体效果为：页面上默认有三条数据，当用户在输入框输入并回车后，将数据添加到列表，点击列表项的x可以实现删除这一项。 12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;input v-model="newTodoText" placeholder="Add a todo" v-on:keyup.enter="todoList.unshift(newTodoText);newTodoText=''"/&gt; &lt;ol&gt; &lt;my-component v-for="(todo,index) in todoList" v-bind:key="index" v-bind:thing="todo" v-on:removething="todoList.splice(index,1)"&gt;&#123;&#123;todo&#125;&#125; &lt;/my-component&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; new Vue(&#123; el: "#app", data:&#123; newTodoText:'', todoList :[ 'Learn Git', 'Learn Webpack', 'Learn Vue-cli' ] &#125;, components:&#123; 'my-component':&#123; template: `&lt;li&gt;&#123;&#123;thing&#125;&#125; &lt;button v-on:click="$emit('removething')"&gt;x&lt;/button&gt;&lt;/li&gt;`, props:['thing'], &#125; &#125; &#125;)&lt;/script&gt; 代码分析 组件my-component被点击后触发removething事件 在父组件中监听removething事件，等其触发后执行操作数组todoList的代码 其中： 当组件被循环的时候，需要添加key属性 1&lt;my-component v-for="(todo,index) in todoList" v-bind:key="index" v-bind:thing="todo" v-on:removething="todoList.splice(index,1)"&gt;&#123;&#123;todo&#125;&#125; &lt;/my-component&gt; 当然这个组件可以重写为： 1&lt;li is="my-component" v-for="(todo,index) in todoList" v-bind:thing="todo" v-on:removething="todoList.splice(index,1)"&gt;&#123;&#123;todo&#125;&#125; &lt;/li&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
        <tag>Vue事件监听</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue父子组件通信]]></title>
    <url>%2F2018%2F05%2F30%2Fvue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[1. 父子组件通讯父组件给子组件传递信息实例 子组件给父组件传递信息123456789101112131415161718192021222324252627282930313233343536...&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;count&#125;&#125; &lt;count-btn v-on:increment="addOne"&gt;&lt;/count-btn&gt; &lt;!--子组件--&gt; &lt;count-btn v-on:increment="addOne"&gt;&lt;/count-btn&gt; &lt;!--子组件--&gt; &lt;/div&gt; &lt;script text="text/javascript"&gt; Vue.component('count-btn',&#123; template:`&lt;button v-on:click="add"&gt;&#123;&#123;btnCount&#125;&#125;&lt;/button&gt;`, methods:&#123; add()&#123; this.btnCount++; this.$emit('increment'); &#125; &#125;, data()&#123; return&#123; btnCount:0, &#125; &#125;, &#125;) new Vue(&#123; el: "#app", data:&#123; count : 0, &#125;, methods:&#123; addOne()&#123; this.count++; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 关于父子组件:12345&lt;div id="app"&gt; &#123;&#123;count&#125;&#125; &lt;count-btn v-on:increment="addOne"&gt;&lt;/count-btn&gt; &lt;!--子组件--&gt; &lt;count-btn v-on:increment="addOne"&gt;&lt;/count-btn&gt; &lt;!--子组件--&gt;&lt;/div&gt; 这里的&lt;count-btn v-on:increment=&quot;addOne&quot;&gt;&lt;/count-btn&gt; 是父组件的一部分，count-btn组件模板template为子组件，子组件为&lt;button v-on:click=&quot;add&quot;&gt;&lt;/button&gt; 分析代码 子组件给父组件传递信息经历的步骤： 子组件监听click事件 &lt;button v-on:click=&quot;add&quot;&gt;&lt;/button&gt; 当触发click事件后，会执行add函数 add 函数中this.$emit(&#39;increment&#39;); 会触发increment事件 父组件&lt;count-btn v-on:increment=&quot;addOne&quot;&gt;&lt;/count-btn&gt; 时刻在监听increment时间，子组件触发该事件后，会执行addOne函数，从而实现子组件给父组件通讯，使得父组件在子组件点击后自增1.]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue父子组件简单介绍]]></title>
    <url>%2F2018%2F05%2F30%2Fvue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1. 理解父子组件可以简单的理解为： 在a组件的模板template中使用的b组件，这个b组件就是a的子组件，a为b的父组件 但是经过个人分析后认为： 在a组件的模板template中使用的b组件，这个b组件的template中的内容才是a的子组件，详细分析见：父子组件通讯 父子组件实例1234567891011121314151617181920212223...&lt;body&gt; &lt;div id="app"&gt; &lt;parent-component&gt;&lt;/parent-component&gt; &lt;/div&gt;&lt;/body&gt;&lt;script text="text/javascript"&gt; var child = Vue.extend(&#123; template:`&lt;div&gt;child&lt;/div&gt;` &#125;); var parent = Vue.extend(&#123; template:`&lt;div&gt;在父组件内部使用子组件必须先注册:&lt;child-component&gt;&lt;/child-component&gt;&lt;/div&gt;`, components:&#123; 'child-component': child, //注册子组件，并将其标签名定义为child-component &#125;, &#125;); new Vue(&#123; el: "#app", components:&#123; 'parent-component': parent, &#125; &#125;)&lt;/script&gt; &lt;div&gt;在父组件内部使用子组件必须先注册:&lt;child-compoent&gt;&lt;/child-component&gt;&lt;/div&gt; 这里父组件中使用子组件child-component 父组件给子组件传值123456789101112131415161718192021222324252627282930...&lt;body&gt; &lt;div id="app"&gt; &lt;parent-component&gt;&lt;/parent-component&gt; &lt;!--父组件--&gt; &lt;/div&gt;&lt;script text="text/javascript"&gt; var child = Vue.extend(&#123; template:`&lt;div&gt;子组件接受的信息为：&#123;&#123;parentName&#125;&#125;,&#123;&#123;parentSex&#125;&#125;&lt;/div&gt;`, props:['parentName','parentSex'], &#125;); var parent = Vue.extend(&#123; template:`&lt;div&gt;父组件信息已传递给子组件：&lt;child-component :parent-name="name" :parent-sex="sex"&gt;&lt;/child-component&gt;&lt;/div&gt;`, components:&#123; 'child-component': child, //注册子组件，并将其标签名定义为child-component &#125;, data()&#123; return &#123; name: 'younguei', sex: 'male', &#125; &#125; &#125;); new Vue(&#123; el: "#app", components:&#123; 'parent-component': parent, &#125; &#125;)&lt;/script&gt; 这个实例有一个父组件、子组件、“孙组件”，实际是实例vm上挂载一个子组件parent-component,该子组件又挂载一个子组件child-component]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT常用指令]]></title>
    <url>%2F2018%2F05%2F28%2Fhexo%E5%8F%8Anext%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[利用Hexo+NexT博客搭建完毕后，这里有一些常用的命令 1.写一篇博客 $hexo new articleTitle 采用默认的post的样式创建一个articleTitle文章 $hexo new [articleStyle] articleTitle 采用articleStyle 样式创建一篇文章 2.博客中的各项参数 layout 文章采用的布局样式 title 标题，可以设置默认标题，在博客配置文件中，通过改变new_post_name 来改变默认文件名称。可以采用:year-:month-:day-:title.md 作为默认默认样式，方便文章管理 date 建立文章的日期 comments 开启文章评论功能，默认开启的，当文章不希望评论时，设置该值为false tags 文章标签,一个文章可能涉及多方面内容，可以多个标签 categories 文章分类，每一个文章只属于某一个类（最好只属于某一个类） description 用于在首页显示文章的概述 例子： （冒号后存在一个空格） 12345678910--- layout: post title: xxxx description: xxxx tags: - tag1 - tag2 - tag3 categories: categorie1--- 3.生成静态文件 $hexo generate 生成静态文件，这里是将文件根目录中的source文件夹内容转换成public静态文件夹 4.本地预览 $hexo server 创建本地服务器，博客开始运行。 注意： (1).在git bash中使用strl+c无法关闭服务器，是因为我这里的热键冲突，我的解决方案是采用Atom的命令行，这里可以正常关闭 (2).有时候修改了博客内容，刷新后仍然无效，这里是缓存的问题，使用$hexo clean命令，该命令会删除public文件夹，重新创建新的public文件夹 5.部署到线上 $hexo generate 生成静态文件，之前有提及 $hexo deploy 将网站部署到服务器，前提是你的git已经和线上服务器绑定，绑定很简单，百度。 这两条命令可以合并: $hexo g -d生成静态文件，并部署到线上]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础命令清单]]></title>
    <url>%2F2018%2F05%2F25%2Fgit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[git的初始设定git init 初始化项目仓库：会创建一个隐藏的.git文件夹 git help config 自动打开浏览器页面,显示对应命令的帮助文档 获取commit命令文档 git help commit 第一次提交 git init 在某个指定的文件夹内初始化仓库 创建一个新文件 git status git add 文件名 提交到索引区 git commit -m 提交描述 将索引区内容提交到本地仓库 git log 查看提交历史 查看提交历史 git log git log --oneline 将提交的历史简化为一行显示 git log -p 将提交历史详细输出 git log --oneline -5 最近5次履历 把握git状态 git status 查看内容状态 git checkout -- 文件名 将修改的（尚未提交到索引区）文件恢复到修改前状态 git reset HEAD 文件名 将提交到索引区域文件退出索引区，再次使用git checkout -- 文件名将文件恢复到以前 比较修改内容 git diff 只能比较尚未添加到索引区的文件内容 git diff --cached 索引区内容比较 git文件操作 git add [file1 file2 ...] 添加若干个文件到索引区 git add . 将当前工作目录内所有文件添加到索引区 gir mv oldfileName newfileName 文件移动，更多用于文件改名 git rm --cached filename 从索引区删除文件 （remove移出） 区别： git reset HEAD 文件名 文件从索引区内退出，此时可以编辑 git rm --cached filename 会从索引区删除文件，会显示untracked fileds当commit后文件就会删除 git忽略管理例如在使用vue-cli中不希望node_modules文件被git管理 方法：在.gitignore文件中设置不需要管理的文件即可 参考网页 在项目目录中创建.gitignore 在.gitignore 写入*.temp表示该文件结尾的文件不被管理 更新最后的提交 git commit -m &#39;message...&#39; git commit --amend 已提交的文件再次修改提交但是不希望有提交记录，这条命令表示将修改的内容合并到上一次，不产生记录 输入：wq 退出，操作成功。 返回过去 git reset --hard HEAD 返回最后一次提交版本 git reset --hard HEAD~ 返回倒数第二个版本 git reset --hard HEAD~n 返回倒数第n个版本 返回过去后再去未来： 记住id号码 git reset --hard HEAD 版本id 那么就会回到id对应的版本 当没记住id怎么回到未来 git reflog [-n num] 显示最近log记录对应的id git reset --hard [commit_id] 利用id来跳转到未来版本 使用分支 git branch [name] 创建新分支 git branch clean_up git checkout branch_name 跳转分支 git branch用于显示分支 合并分支 git merge branch_name合并分支 git branch -d branch_name删除分支 分支冲突解决多人同时编辑一个文件的时候，对相同代码在不同分支上进行不同操作，合并分支会产生冲突。 git checkout -b [branch_name] 建立一个新分支，并切换到该分支上 解决方法：手动解决冲突代码，之后提交到仓库 git commit -m &#39;merged by leader&#39; 使用tag标签任何软件系统，应用程序在发布时候都应该给一个版本号，用来管理每次发布的内容，便于管理。 tag标签用于版本管理 NNN.abc.xxx NNN:大版本号 abc: 每次做出的小更新版本 xxx: 每次bug修正时发布的版本 git tag [tag_name] 为当前仓库打一个标签 git show [tag_name] git tag -d [tag_name] git tag 显示当前版本标签 使用别名在git中可以将常用的命令设置简写 git config --global alias.[name] [command_name] git config -l 显示所有命令缩略语 git config --global alias.br branch 将branch命令简写为br 本地git仓库连接到远程github git remote add origin 远程仓库url地址 将本地仓库关联到远程仓库 git push -u origin master 将本地仓库内容推送到远程 第一次推送的时候需要添加-u参数，该参数的作用是将本地的master分支推送到远程master分支上 git push origin master 推送命令简化，在第二次及以后的推送时使用该命令，默认推送到master分支上。 从远程github克隆仓库最好先建远程库，再从远程克隆到本地 git clone 远程仓库url 克隆远程仓库到本地 添加git忽略管理文件 .gitignore在文件内添加 node_modules 看视频中随便敲的首次安装git需要设置用户名和邮箱git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;Your email&quot; pwd print working directory git config --list列出所有的配置 user.name user.email 都在其中 git status 查看当前项目的状态 git add 文件名 将对应的文件添加到stage区域中，stage区域中的文件可以被提交到仓库 git commit -m 操作描述将stage内所有文件提交到仓库 git add&#39;*.txt&#39; 利用通配符将所有新txt文件添加到stage中 git commit -m &#39;Add all the octocat txt files&#39; 将stage内所有的文件提交到仓库 git log 显示我们之前的操作 git remote add origin url 将本地仓库提交到远程仓库 url为远程仓库地址 git push -u origin master 远程仓库名为origin，默认分支名为master，-u表示保存配置，下次使用git push来直接提交到远程仓库 git pull origin master从远程仓库获取到本地 git diff HEAD 查看最近提交的不同之处 git diff --staged 用于查看staged区域中文件的变化 git reset 文件名将stage内对应的文件移出stage git checkout -- 文件名直接删除文件 git branch 分支名创建新分支 git checkout 分支名 将当前操作的分支切换到对应的分支名上 git re &#39;*.txt&#39; 利用通配符，移除对应的文件 git commit -m ’emove all the cats‘ git merge 分支名 将对应的分支名与当前的处在的分支合并 git branch -d 分支名 删除分支]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli笔记]]></title>
    <url>%2F2018%2F05%2F01%2FvueCli%2F</url>
    <content type="text"><![CDATA[Vue-cli安装vue-cli是构建单页面应用的脚手架 npm install vue-cli -g 检查vue-cli版本vue - V 初始化项目 vue init &lt;template-name&gt; &lt;project-name&gt; 初始化项目完毕后，就可以写自己的项目了。 注意： npm run dev报错 12Module build failed: Error: &quot;extract-text-webpack-plugin&quot; loader is used without the corresponding plugin, refer to https://github.com/webpack/extract-text-webpack-plugin for the usage example 解决方法:参考 在webpack.base.conf.js中添加以下代码 12345678910111213141516const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);.... &#123; test: /\.scss$/, use: ExtractTextPlugin.extract(&#123; use: [ &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;) &#125; ... plugins: [ new ExtractTextPlugin(&#123; filename: &apos;./[name].css&apos; &#125;) ] Vue-cli安装的webpack项目目录介绍几个重要的文件: dev-server.js 服务器文件 webpack.base.config.js webpack的基础配置文件 .babelrc 把ES6转换为ES5代码 .editorconfig 定义项目的编码规范，编译器的行为会与该文件中定义的一致，并且高于编译器自身的设置要高 index.html 项目的入口页面 main.js 程序入口文件，用于加载js与css等文件 App.vue 页面组件 疑问： 项目执行流程，页面入口index.html引入main.js ，main.js引入组件App.vue，index.js中路由怎么执行的，程序执行流程是什么，还需要vue-router内容来支撑。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JSpang系列教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开博客的原因]]></title>
    <url>%2F2017%2F11%2F20%2FmyBlog%2F</url>
    <content type="text"><![CDATA[简介通过各种查找资料，走过各种弯路，解决了一个接一个问题，博客初步完成了，博客的主要用途是记录自己前端学习历程，心情不好的时候也会写一些对生活的心得、感想，记录下自己那些难忘的岁月。 正文1、博客创建所用到的资源 GitHub 从零开始创建一个博客是很累人的，好在github上的开源博客项目，只需修改自己相关内容，可以更好的专注于博客内容的书写。 百度统计 博客浏览量统计，通过分析可以得到浏览博客网友的区域分布，浏览高峰时间段。 来必力 评论系统，很方便，几行代码copy到博客中，就可以显示评论区域框架结构，更棒的是可以在其网站上分析各种评论数据。 typora Markdown编辑器，所写即所得，高效、快捷。 2、鸣谢 [酒石酸菌] 基于 GitHub Pages 和 Jekyll 搭建个人博客的简单心得。 leopardpan 点击链接就可以访问原作者的Github的开源博客项目。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活记录</tag>
      </tags>
  </entry>
</search>
